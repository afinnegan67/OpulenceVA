<div class="pb-wrap">
  <div class="pb-head glass">
    <div>
      <h3>Problems</h3>
      <p>Detected scheduling issues from Airtable</p>
    </div>
    <div class="controls">
      <input id="search" class="input" placeholder="Search task, project, crew…" />
      <label class="pill">
        <span>Type</span>
        <select id="filterType" class="select">
          <option value="">All</option>
          <option value="conflict">Crew Conflict</option>
          <option value="overdue">Overdue</option>
          <option value="missing-crew">Missing Crew</option>
          <option value="invalid-dates">Invalid Dates</option>
          <option value="end-before-start">End Before Start</option>
        </select>
      </label>
      <label class="pill">
        <span>Crew</span>
        <select id="filterCrew" class="select"><option value="">All</option></select>
      </label>
      <label class="pill">
        <span>Project</span>
        <select id="filterProject" class="select"><option value="">All</option></select>
      </label>
      <button id="getBtn" class="btn">Refresh</button>
      <span id="status" class="status" style="display:none;"></span>
    </div>
  </div>

  <div id="kpis" class="kpis">
    <!-- KPI tiles -->
  </div>

  <div class="panel glass">
    <div class="list-head">
      <div>Type</div>
      <div>Task</div>
      <div>Project</div>
      <div>Crew</div>
      <div>Dates</div>
      <div>Details</div>
    </div>
    <div id="list" class="list">
      <!-- Issues rows -->
    </div>
  </div>
</div>

<style>
  .pb-wrap { font-family: system-ui, Arial, sans-serif; color:#e5e7eb; }
  .pb-head { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:14px; padding:14px 16px; border-radius:16px; }
  .pb-head h3 { margin:0; font-size:1.25rem; color:#dbeafe; letter-spacing:.2px; }
  .pb-head p { margin:2px 0 0; font-size:.9rem; color:#a5b4fc; }
  .controls { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .input, .select {
    background: rgba(255,255,255,.06); color:#e5e7eb; border:1px solid rgba(255,255,255,.18);
    border-radius:10px; padding:8px 10px; outline:none; min-width:210px;
  }

  .glass {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.18);
    backdrop-filter: blur(14px) saturate(120%);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 14px 44px rgba(0,0,0,0.28), 0 2px 10px rgba(0,0,0,0.18);
    position: relative;
  }
  .glass::before {
    content:""; position:absolute; inset:0; border-radius:inherit; pointer-events:none;
    background:
      linear-gradient(180deg, rgba(255,255,255,.10), transparent 30%),
      linear-gradient(90deg, rgba(255,255,255,.05), transparent 40% 60%, rgba(255,255,255,.04));
  }

  .btn {
    appearance:none; border:1px solid rgba(255,255,255,.22); color:#0b1021; font-weight:700;
    background: linear-gradient(135deg, #60a5fa 0%, #8b5cf6 100%);
    padding:8px 12px; border-radius:10px; cursor:pointer;
  }
  .btn:disabled{ opacity:.6; cursor:not-allowed; }
  .status { font-size:.9rem; color:#a5b4fc; }

  .kpis {
    display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap:12px; margin-bottom:14px;
  }
  .tile { padding:14px; border-radius:16px; position:relative; }
  .tile h4 { margin:0 0 4px; font-size:.85rem; color:#c7d2fe; font-weight:600; }
  .tile .value { font-size:1.6rem; font-weight:800; color:#ffffff; }

  .panel { padding:14px; border-radius:16px; }
  .list-head, .row {
    display:grid; grid-template-columns: 1.1fr 1.6fr 1.2fr 1.1fr 1.2fr 1.4fr; gap:10px; align-items:center;
  }
  .list-head { color:#93c5fd; font-size:.85rem; border-bottom:1px solid rgba(255,255,255,.08); padding-bottom:8px; margin-bottom:6px; }
  .row { padding:10px 0; border-bottom:1px solid rgba(255,255,255,.06); }
  .badge {
    display:inline-block; font-size:.75rem; padding:4px 8px; border-radius:999px; color:#fff; text-transform:capitalize;
    border:1px solid rgba(255,255,255,.18);
  }
  .type-conflict { background:linear-gradient(135deg, #ef4444, #f97316); }
  .type-overdue { background:linear-gradient(135deg, #f43f5e, #fb7185); }
  .type-missing-crew { background:linear-gradient(135deg, #6b7280, #94a3b8); }
  .type-invalid-dates { background:linear-gradient(135deg, #94a3b8, #64748b); }
  .type-end-before-start { background:linear-gradient(135deg, #0ea5e9, #3b82f6); }
  .muted { color:#a5b4fc; font-size:.9rem; }
  @media (max-width: 980px){
    .list-head, .row { grid-template-columns: 1.1fr 1.6fr 1.2fr 1.1fr 1.4fr; }
  }
</style>

<script>
(function(){
  const cfg = window.OPULENCE || {};
  const isLocalStatic = ['localhost','127.0.0.1'].includes(location.hostname);

  // Try problems endpoints first; fall back to schedule if missing
  const CANDIDATE_APIS = [
    cfg.problemsApi || (isLocalStatic ? 'http://localhost:3000/api/problems' : '/api/problems'),
    isLocalStatic ? 'http://localhost:3000/api/issues'   : '/api/issues',
    isLocalStatic ? 'http://localhost:3000/api/schedule' : '/api/schedule'
  ];

  const getBtn = document.getElementById('getBtn');
  const statusEl = document.getElementById('status');
  const kpisEl = document.getElementById('kpis');
  const listEl = document.getElementById('list');
  const filterType = document.getElementById('filterType');
  const filterCrew = document.getElementById('filterCrew');
  const filterProject = document.getElementById('filterProject');
  const searchEl = document.getElementById('search');

  const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
  function parseDate(value){
    if (!value) return null;
    if (value instanceof Date) return isNaN(value) ? null : value;
    if (typeof value === 'number') return new Date(value);
    const s = String(value).trim();
    let m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s);
    if (m) { const dt = new Date(+m[1], +m[2]-1, +m[3]); return isNaN(dt) ? null : dt; }
    m = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(s);
    if (m) { const dt = new Date(+m[3], +m[1]-1, +m[2]); return isNaN(dt) ? null : dt; }
    const dt = new Date(s); return isNaN(dt) ? null : dt;
  }
  function parsePercent(v){
    if (typeof v === 'number') return v <= 1 ? Math.round(v * 100) : Math.round(v);
    if (typeof v === 'string') {
      const t = v.trim();
      if (t.endsWith('%')) return clamp(parseFloat(t.slice(0,-1)) || 0, 0, 100);
      const n = parseFloat(t);
      if (!isNaN(n)) return n <= 1 ? Math.round(n*100) : Math.round(n);
    }
    return 0;
  }
  const fmtDate = d => { if (!d) return '—'; const t=new Date(d); return isNaN(t)?'—':t.toLocaleDateString([], {month:'short', day:'numeric'}); };
  const escapeHTML = s => String(s||"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));

  // Compute issues from schedule tasks (fallback)
  function normalizeTasks(tasks){
    return tasks.map(t => {
      const name = t.name || t.task || t.Task || t.Title || t.taskName || t['Task Name'] || t.id || t.taskId || '—';
      const project = t.project || t.Project || t['Project Name'] || '';
      let crew = t.crew ?? t.Crew ?? t['Assigned Crew'] ?? t['Crew Member'] ?? '';
      if (Array.isArray(crew)) crew = crew.join(', ');
      crew = String(crew || '').trim();
      const startDate = t.startDate || t.start || t['Start'] || t['Start Date'] || t['StartDate'] || '';
      const endDate   = t.endDate   || t.end   || t['End']   || t['End Date']   || t['EndDate']   || '';
      let percentComplete = t.percentComplete ?? t['Percent Complete'] ?? t['% Complete'] ?? t.percent ?? t['Percent'] ?? 0;
      percentComplete = parsePercent(percentComplete);
      return { ...t, name, project, crew, startDate, endDate, percentComplete };
    });
  }

  // Normalize Airtable Problems table records
  function normalizeProblemsRecords(records){
    return records.map(rec => {
      const f = rec.fields || {};
      const id = rec.id || f['Problem ID'] || f['ID'] || '';
      const problemId = f['Problem ID'] || '';
      const rawType = f['Type'] || 'Issue';
      const type = sanitizeType(rawType); // for CSS class
      const description = f['Description'] || '';
      const project = f['Project'] || '';
      const reported = f['Reported Date'] || f['Reported'] || f['Date'] || '';
      const status = f['Status'] || '';
      const severity = f['Severity'] || '';
      const assigned = f['Assigned to'] || f['Assigned'] || '';

      // adapt to list UI shape; reuse task envelope used elsewhere
      const task = {
        id, name: problemId || rawType, project,
        crew: Array.isArray(assigned) ? assigned.join(', ') : String(assigned || ''),
        startDate: reported, endDate: reported
      };

      return {
        source: 'problems',
        type, rawType, status, severity, task,
        detail: description
      };
    });
  }

  function sanitizeType(s){
    return String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'') || 'issue';
  }

  // Pretty gradient for any type string
  function typeGradient(typeStr){
    const s = String(typeStr||'issue');
    let h = 0; for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i)) % 360;
    const h2 = (h + 30) % 360;
    return `linear-gradient(135deg, hsl(${h} 85% 60%), hsl(${h2} 80% 65%))`;
  }

  function buildIssuesFromTasks(tasks){
    const issues = [];
    const today = new Date(); today.setHours(0,0,0,0);

    const byCrew = new Map();
    for (const t of tasks){
      const crewTokens = String(t.crew||'').split(',').map(s=>s.trim()).filter(Boolean);
      if (!crewTokens.length) {
        if (!byCrew.has('')) byCrew.set('', []);
        byCrew.get('').push(t);
      } else {
        for (const c of crewTokens){
          if (!byCrew.has(c)) byCrew.set(c, []);
          byCrew.get(c).push(t);
        }
      }
    }

    for (const t of tasks){
      const s = parseDate(t.startDate);
      const e = parseDate(t.endDate);
      const pct = parsePercent(t.percentComplete);
      if (!s || (t.endDate != null && t.endDate !== '' && !e)) {
        issues.push({ type:'invalid-dates', task:t, detail:'Missing or invalid date(s)' });
      }
      if (s && e && e < s) {
        issues.push({ type:'end-before-start', task:t, detail:'End date before start date' });
      }
      if (!String(t.crew||'').trim()) {
        issues.push({ type:'missing-crew', task:t, detail:'No crew assigned' });
      }
      if (e && e < today && pct < 100) {
        issues.push({ type:'overdue', task:t, detail:`Past due (${fmtDate(e)}) at ${pct}%` });
      }
    }

    for (const [crew, list] of byCrew.entries()){
      if (!crew) continue;
      const arr = list.map(t => ({ t, s:parseDate(t.startDate), e:parseDate(t.endDate)||parseDate(t.startDate) }))
                      .filter(x => x.s);
      arr.sort((a,b) => a.s - b.s);
      for (let i=1;i<arr.length;i++){
        const prev = arr[i-1], cur = arr[i];
        if (prev.e >= cur.s) {
          issues.push({
            type:'conflict',
            task:cur.t,
            detail:`Overlaps (${fmtDate(prev.s)}–${fmtDate(prev.e)}) for ${crew}`
          });
        }
      }
    }

    return issues;
  }

  function summarize(issues){
    // If issues came from Problems table, they have status/severity/rawType
    const isProblems = issues.some(i => i.source === 'problems');
    if (isProblems){
      const total = issues.length;
      const statusCounts = new Map();
      const severityCounts = new Map();
      for (const i of issues){
        statusCounts.set(i.status || 'Unknown', (statusCounts.get(i.status || 'Unknown')||0)+1);
        severityCounts.set(i.severity || 'Unknown', (severityCounts.get(i.severity || 'Unknown')||0)+1);
      }
      return { total, statusCounts, severityCounts };
    } else {
      const total = issues.length;
      const counts = { conflict:0, overdue:0, 'missing-crew':0, 'invalid-dates':0, 'end-before-start':0 };
      for (const i of issues){ if (counts[i.type] != null) counts[i.type]++; }
      return { total, counts };
    }
  }

  function renderKPIs(sum){
    // Problems table KPIs
    if (sum.statusCounts){
      const open = sum.statusCounts.get('Open') || 0;
      const inprog = sum.statusCounts.get('In Progress') || 0;
      const resolved = sum.statusCounts.get('Resolved') || 0;
      const high = (sum.severityCounts.get('High') || 0);

      kpisEl.innerHTML = `
        <div class="tile glass"><h4>Total Issues</h4><div class="value">${sum.total}</div></div>
        <div class="tile glass"><h4>Open</h4><div class="value">${open}</div></div>
        <div class="tile glass"><h4>In Progress</h4><div class="value">${inprog}</div></div>
        <div class="tile glass"><h4>Resolved</h4><div class="value">${resolved}</div></div>
        <div class="tile glass"><h4>High Severity</h4><div class="value">${high}</div></div>
      `;
      return;
    }
    // Fallback schedule-derived KPIs
    kpisEl.innerHTML = `
      <div class="tile glass"><h4>Total Issues</h4><div class="value">${sum.total}</div></div>
      <div class="tile glass"><h4>Conflicts</h4><div class="value">${sum.counts.conflict}</div></div>
      <div class="tile glass"><h4>Overdue</h4><div class="value">${sum.counts.overdue}</div></div>
      <div class="tile glass"><h4>Missing Crew</h4><div class="value">${sum.counts['missing-crew']}</div></div>
      <div class="tile glass"><h4>Invalid Dates</h4><div class="value">${sum.counts['invalid-dates'] + sum.counts['end-before-start']}</div></div>
    `;
  }

  function populateFiltersFromProblems(issues){
    // dynamic Type/Crew/Project options for Problems data
    const types = new Set(), crews = new Set(), projs = new Set();
    for (const i of issues){
      if (i.rawType) types.add(String(i.rawType));
      String(i.task?.crew||'').split(',').map(s=>s.trim()).filter(Boolean).forEach(c => crews.add(c));
      if (i.task?.project) projs.add(String(i.task.project));
    }
    const tVal = filterType.value, cVal = filterCrew.value, pVal = filterProject.value;
    filterType.innerHTML = `<option value="">All</option>` + [...types].sort().map(t=>`<option ${t===tVal?'selected':''}>${escapeHTML(t)}</option>`).join('');
    filterCrew.innerHTML  = `<option value="">All</option>` + [...crews].sort().map(c=>`<option ${c===cVal?'selected':''}>${escapeHTML(c)}</option>`).join('');
    filterProject.innerHTML = `<option value="">All</option>` + [...projs].sort().map(p=>`<option ${p===pVal?'selected':''}>${escapeHTML(p)}</option>`).join('');
  }

  function populateFiltersFromTasks(tasks){
    const crews = new Set(), projs = new Set();
    for (const t of tasks){
      String(t.crew||'').split(',').map(s=>s.trim()).filter(Boolean).forEach(c => crews.add(c));
      if (t.project) projs.add(String(t.project));
    }
    const cVal = filterCrew.value, pVal = filterProject.value;
    // Keep Type list as-is for schedule-derived issues (conflict/overdue/etc)
    filterCrew.innerHTML  = `<option value="">All</option>` + [...crews].sort().map(c=>`<option ${c===cVal?'selected':''}>${escapeHTML(c)}</option>`).join('');
    filterProject.innerHTML = `<option value="">All</option>` + [...projs].sort().map(p=>`<option ${p===pVal?'selected':''}>${escapeHTML(p)}</option>`).join('');
  }

  function visible(issues){
    const typeSel = filterType.value;
    const crewSel = filterCrew.value;
    const projSel = filterProject.value;
    const q = searchEl.value.trim().toLowerCase();

    return issues.filter(i => {
      const t = i.task || {};
      // Match by Problems rawType if present, otherwise by computed type
      if (typeSel) {
        const typeMatch = i.rawType ? (i.rawType === typeSel) : (i.type === sanitizeType(typeSel));
        if (!typeMatch) return false;
      }
      if (crewSel) {
        const crewTokens = String(t.crew||'').split(',').map(s=>s.trim());
        if (!crewTokens.includes(crewSel)) return false;
      }
      if (projSel && String(t.project||'') !== projSel) return false;

      if (q){
        const hay = `${i.rawType||i.type||''} ${t.name||''} ${t.project||''} ${t.crew||''} ${i.detail||''} ${i.status||''} ${i.severity||''}`.toLowerCase();
        if (!hay.includes(q)) return false;
      }
      return true;
    });
  }

  function renderList(issues){
    if (!issues.length){
      listEl.innerHTML = `<div class="muted" style="padding:12px;">No issues detected.</div>`;
      return;
    }
    listEl.innerHTML = issues.map(i => {
      const t = i.task || {};
      const dates = `${fmtDate(t.startDate)} — ${fmtDate(t.endDate)}`;
      const typeLabel = i.rawType || i.type.replace(/-/g,' ');
      const badgeStyle = `style="background:${typeGradient(typeLabel)}"`;
      const meta = (i.status || i.severity) ? ` • ${escapeHTML(i.status||'')} ${i.severity?('• '+escapeHTML(i.severity)) : ''}` : '';
      return `
        <div class="row">
          <div><span class="badge" ${badgeStyle}>${escapeHTML(typeLabel)}</span></div>
          <div class="muted">${escapeHTML(t.name || '—')}</div>
          <div class="muted">${escapeHTML(t.project || '—')}</div>
          <div class="muted">${escapeHTML(t.crew || '—')}</div>
          <div class="muted">${dates}</div>
          <div class="muted">${escapeHTML(i.detail || '—')}${meta}</div>
        </div>
      `;
    }).join('');
  }

  let ISSUES = [];
  let SOURCE = 'problems'; // 'problems' or 'schedule'

  async function getProblems(){
    try {
      getBtn.disabled = true;
      getBtn.textContent = 'Loading…';
      statusEl.style.display = 'inline';
      statusEl.style.color = '#a5b4fc';
      statusEl.textContent = 'Fetching from API…';

      let data = null, usedApi = null, lastErr = null;

      for (const api of CANDIDATE_APIS){
        try {
          const u = new URL(api, window.location.origin);
          if (cfg.baseId) u.searchParams.set('baseId', cfg.baseId);
          if (cfg.problemsTableId) u.searchParams.set('problemsTableId', cfg.problemsTableId);
          if (cfg.problemsTableName) u.searchParams.set('problemsTableName', cfg.problemsTableName);
          if (cfg.scheduleTableId) u.searchParams.set('scheduleTableId', cfg.scheduleTableId);
          if (cfg.scheduleTableName) u.searchParams.set('scheduleTableName', cfg.scheduleTableName);

          const r = await fetch(u.toString(), { cache:'no-store' });
          if (!r.ok) { lastErr = `${r.status} ${await r.text()}`; continue; }
          data = await r.json();
          usedApi = api;
          break;
        } catch (e) {
          lastErr = e.message;
        }
      }

      if (!data) throw new Error(`No problems API responded (${lastErr||'unknown error'})`);

      // Detect shape
      if (Array.isArray(data.records)) {
        // Airtable Problems table
        const records = data.records;
        ISSUES = normalizeProblemsRecords(records);
        SOURCE = 'problems';
        populateFiltersFromProblems(ISSUES);
      } else if (Array.isArray(data.problems)) {
        // Custom problems API returning array of issue-like objects; map minimally
        ISSUES = (data.problems||[]).map(i => ({
          source:'problems',
          type: sanitizeType(i.type || 'issue'),
          rawType: i.type || 'Issue',
          status: i.status || '',
          severity: i.severity || '',
          detail: i.description || i.detail || '',
          task: {
            id: i.id || '',
            name: i.id || i.type || 'Issue',
            project: i.project || '',
            crew: Array.isArray(i.assigned) ? i.assigned.join(', ') : (i.assigned || ''),
            startDate: i.reportedDate || i.date || '',
            endDate:   i.reportedDate || i.date || ''
          }
        }));
        SOURCE = 'problems';
        populateFiltersFromProblems(ISSUES);
      } else if (Array.isArray(data.tasks)) {
        // Schedule fallback: compute issues
        const tasks = normalizeTasks(data.tasks);
        ISSUES = buildIssuesFromTasks(tasks);
        SOURCE = 'schedule';
        populateFiltersFromTasks(tasks);
      } else {
        throw new Error('Unknown API response shape');
      }

      const sum = summarize(ISSUES);
      renderKPIs(sum);
      renderList(visible(ISSUES));

      statusEl.style.color = '#86efac';
      statusEl.textContent = `Done. ${ISSUES.length} issues loaded (${SOURCE}).`;
    } catch (e){
      statusEl.style.color = '#fca5a5';
      statusEl.textContent = `Error: ${e.message}`;
      console.error(e);
      kpisEl.innerHTML = '';
      listEl.innerHTML = `<div class="muted" style="padding:12px;">Failed to load problems.</div>`;
    } finally {
      getBtn.disabled = false;
      getBtn.textContent = 'Refresh';
    }
  }

  filterType.addEventListener('change', () => renderList(visible(ISSUES)));
  filterCrew.addEventListener('change', () => renderList(visible(ISSUES)));
  filterProject.addEventListener('change', () => renderList(visible(ISSUES)));
  searchEl.addEventListener('input', () => renderList(visible(ISSUES)));
  getBtn.addEventListener('click', getProblems);
})();
</script>
