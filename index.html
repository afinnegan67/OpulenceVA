<!DOCTYPE html>
<html lang="en">
<head>
  <script>
    // Simplified dashboard loader (reverted to workingindex.html pattern)
    window.OPULENCE = window.OPULENCE || {};
    const VIEW_MAP = {
      overview: 'Components/overview.html',
      schedule: 'Components/schedule.html',
      crew: 'Components/crew.html',
      problems: 'Components/problems.html'
    };
    const spaceEl = document.getElementById('dashboardSpace');
    const navEl = document.getElementById('topnav');

    async function loadDashboard(name){
      const file = VIEW_MAP[name];
      if(!file) return;
      // nav state
      navEl?.querySelectorAll('button').forEach(b=>b.classList.toggle('active', b.dataset.view===name));
      // loading placeholder
      spaceEl.innerHTML = `<div><div class="loader"></div><div style="color:#6b7280">Loading ${name}‚Ä¶</div></div>`;
      try {
        const r = await fetch(file,{cache:'no-store'});
        if(!r.ok) throw new Error(`Failed to load ${file} (${r.status})`);
        const html = await r.text();
        spaceEl.innerHTML = html;
        executeScripts(spaceEl);
        const AUTO_INIT = new Set(['crew','overview','schedule','problems']);
        if (AUTO_INIT.has(name)) setTimeout(()=>{ const btn=spaceEl.querySelector('#getBtn'); if(btn && !btn.disabled) btn.click(); },50);
        location.hash = `#/${name}`; // maintain hash
      } catch(e){
        spaceEl.innerHTML = `<div class="dashboard-placeholder"><div class="icon">‚ö†Ô∏è</div><p>Couldn't load <strong>${name}</strong>.</p><p style=\"color:#6b7280\">${e.message}</p></div>`;
      }
    }

    function executeScripts(container){
      container.querySelectorAll('script').forEach(sc=>{ const s=document.createElement('script'); if(sc.src) s.src=sc.src; else s.textContent=sc.innerHTML; document.body.appendChild(s); document.body.removeChild(s); });
    }
    window.loadDashboard = loadDashboard;
    navEl?.addEventListener('click', e=>{ const btn=e.target.closest('button[data-view]'); if(btn) loadDashboard(btn.dataset.view); });
    function bootFromHash(){ const m=location.hash.match(/^#\/(\w+)/); const v=m&&m[1]; if(v && VIEW_MAP[v]) loadDashboard(v); }
    window.addEventListener('hashchange', bootFromHash); bootFromHash();
    if(!location.hash) loadDashboard('overview');

    // Voice widget bridge & status
    function showVoiceStatus(msg){ const el=document.getElementById('voiceStatus'); if(!el) return; el.textContent=msg; el.classList.add('show'); setTimeout(()=>el.classList.remove('show'),3000);}    
    window.addEventListener('message', ev=>{ const d=ev.data; if(!d) return; if(d.type==='vapi-widget'){ if(d.event==='call-start') showVoiceStatus('üé§ Voice call started'); else if(d.event==='call-end') showVoiceStatus('üëã Voice call ended'); else if(d.event==='message' && d.message?.transcript) showVoiceStatus(`"${d.message.transcript}"`); } if(d.type==='opulence' && d.action==='loadDashboard'){ const v=String(d.name||'').toLowerCase(); if(VIEW_MAP[v]) loadDashboard(v); }});

    // Simple polling for /api/voice-intent
    (function(){
      const ALLOWED=new Set(['overview','schedule','crew','problems']);
      let lastUpdate=0;
      async function poll(){
        try{
          const u=new URL('/api/voice-intent', location.origin);
          if(lastUpdate) u.searchParams.set('since', lastUpdate);
          const res=await fetch(u.toString(),{cache:'no-store'});
          if(!res.ok) return;
          const j=await res.json();
            if(j.updatedAt && j.updatedAt>lastUpdate) lastUpdate=j.updatedAt;
            const view=String(j.view||'').toLowerCase();
            if(j.changed && ALLOWED.has(view)) loadDashboard(view);
        }catch(e){ console.warn('[voice] poll error', e.message); }
      }
      try{ clearInterval(window._voicePollTimer);}catch{}
      window._voicePollTimer=setInterval(poll,2000);
    })();

    // Manual tester
    window.voiceTest = async function(view){ try { const r=await fetch('/api/voice-intent',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({view})}); const j=await r.json(); console.log('[voiceTest]', j); if(j.view && VIEW_MAP[j.view]) loadDashboard(j.view); } catch(e){ console.warn(e);} };

    console.log('Opulence Dashboard initialized (simplified mode)');
  </script>
          try {
            const data = event.data;
            if (!data) return;
            if (this.DEBUG) console.debug('[voice] message', data);

            if (data.type === 'vapi-widget') {
              this.handleVapiEvent(data);
            } else if (data.type === 'opulence') {
              const view = this.extractView(data) || this.extractView(data.payload) || this.mapUtteranceToView(data.text || data.transcript);
              if (view && this.viewMap[view]) this.setHashView(view);
            }
          } catch (error) {
            console.warn('[voice] Message handling error:', error.message);
          }
        });

        this.startVoicePolling();
      }

      handleVapiEvent(data) {
        switch (data.event) {
          case 'call-start':
            this.showVoiceStatus('üé§ Voice call started');
            break;
          case 'call-end':
            this.showVoiceStatus('üëã Voice call ended');
            break;
          case 'message': {
            const msg = data.message || {};
            if (msg.transcript) this.showVoiceStatus(`"${msg.transcript}"`);
            const view =
              this.extractView(msg) ||
              this.extractView(msg.data) ||
              this.extractView(msg.metadata) ||
              this.mapUtteranceToView(msg.transcript || msg.text);
            if (view && this.viewMap[view]) {
              this.setHashView(view);
              this.showVoiceStatus(`Switching to ${view}`);
            }
            break;
          }
        }
      }

      // Central helper to update the URL hash; triggers bootFromHash() via hashchange.
      setHashView(view) {
        if (!this.viewMap[view]) return;
        const targetHash = `#/${view}`;
        if (location.hash === targetHash) {
          // Force reload same view: temporarily clear then set again.
            if (this.DEBUG) console.log('[DEBUG] Hash already set; forcing reload for view:', view);
            location.hash = '#/_'; // temp invalid hash
            setTimeout(()=>{ location.hash = targetHash; }, 10);
        } else {
          location.hash = targetHash;
        }
      }

      async startVoicePolling() {
        const poll = async () => {
          try {
            const url = new URL(this.buildVoiceUrl('/api/voice-intent'));
            if (this.lastToken) url.searchParams.set('since', this.lastToken);
            if (this.DEBUG) console.debug('[voice] polling', url.toString());

            const response = await fetch(url.toString(), { cache: 'no-store' });
            if (!response.ok) return;

            const data = await response.json();
            if (this.DEBUG) console.debug('[voice] poll result', data);

            // Prefer explicit revision counter if present
            const token = data.rev ?? data.updatedAt ?? data.ts ?? data.version ?? data.revision ?? null;
            const view =
              this.extractView(data) ||
              this.extractView(data.intent) ||
              this.extractView(data.payload) ||
              this.mapUtteranceToView(data.transcript || data.text || data.command) ||
              (typeof data.view === 'string' ? data.view.toLowerCase() : null);

            // If this is the very first poll, seed token and do NOT treat existing state as a change.
            if (this.lastToken == null && token != null) {
              this.lastToken = token;
              if (this.DEBUG) console.log('[voice] Initial poll seeded token; ignoring stale view:', view);
              return; // skip processing first poll to avoid stale auto-switch
            }

            const hasChanged = Boolean(data.changed) ||
                               (token != null && token !== this.lastToken) ||
                               (view && view !== this.currentView);

            if (view && this.viewMap[view] && hasChanged) {
              if (this.DEBUG) console.log('[DEBUG] Voice polling detected view change (hash route):', view, 'hasChanged:', hasChanged);
              this.setHashView(view);
              this.showVoiceStatus(`Switched to ${view}`);
            } else if (this.DEBUG) {
              console.log('[DEBUG] Voice polling - no view change:', {view, hasChanged, currentView: this.currentView});
            }

            if (token != null) this.lastToken = token;
          } catch (error) {
            console.warn('[voice] Polling error:', error.message);
          }
        };

        try { clearInterval(window._voicePollTimer); } catch {}
        window._voicePollTimer = setInterval(poll, 2000);
      }
    }

    // Initialize dashboard
    const dashboard = new DashboardManager();
    dashboard.init();
    window.loadDashboard = (view) => dashboard.loadView(view);

    // Debug helpers
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'd') {
        const next = localStorage.opulenceDebug === '1' ? '0' : '1';
        localStorage.opulenceDebug = next;
        console.log(`[voice] debug ${next === '1' ? 'enabled' : 'disabled'} ‚Äî reloading`);
        location.reload();
      }
    });

    // UPDATED: use the same base for manual testing as Vapi
    window.voiceTest = async function(view) {
      try {
        const url = dashboard.buildVoiceUrl('/api/voice-intent');
        const r = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ view })
        });
        const j = await r.json();
        console.log('[voiceTest] POST', url, '‚Üí', j);
        if (j.view && dashboard.viewMap[j.view]) {
          dashboard.setHashView(j.view);
          dashboard.showVoiceStatus(`Switched to ${j.view} (manual)`);
        }
      } catch (e) {
        console.warn('[voiceTest] failed:', e);
      }
    };

    console.log('Opulence Dashboard initialized');
  </script>
</body>
</html>
